<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Keyspire&#39;s Peakory</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  <meta name="description" content="Kpy&#39;s Blog">
  
  
  
    <link rel="shortcut icon" href="../../img/favicon.ico">
  
  <link rel="stylesheet" href="../../css/style.css">
  
    <link rel="stylesheet" href="../../fancybox/jquery.fancybox-1.3.4.css">
  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <div id="nav-outer">
  <nav id="main-nav" class="outer">
    <a id="main-nav-toggle" class="nav-icon"></a>
    
      <a class="main-nav-link" href="../../index.html">Home</a>
    
      <a class="main-nav-link" href="../../way2/archives">Archives</a>
    
      <a class="main-nav-link" href="../../about">About</a>
    
    <div class="main-nav-space-between"></div>
    
  </nav>
</div>
<div id="header-title">
  <h1 id="logo-wrap">
    <a href="../../index.html" id="logo">Keyspire&#39;s Peakory</a>
  </h1>
  
    <h2 id="subtitle-wrap">
      <a href="../../index.html" id="subtitle">which is Kpy&#39;s Blog</a>
    </h2>
  
</div>

      <div id="content" class="outer">
        <section id="main">
  
    <article id="post-projs/C++ TinyWebServer 项目实践" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="../../2023/04/03/projs/C++%20TinyWebServer%20%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%B7%B5/" class="article-date">
  <time class="dt-published" datetime="2023-04-02T16:00:00.000Z" itemprop="datePublished">2023-04-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="../../2023/04/03/projs/C++%20TinyWebServer%20%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%B7%B5/">C++ TinyWebServer项目实践</a>
    </h1>
  

      </header>
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="项目简介"><a href="#项目简介" class="headerlink" title="项目简介"></a>项目简介</h2><p>源-项目地址:  <a target="_blank" rel="noopener" href="https://github.com/qinguoyi/TinyWebServer">qinguoyi&#x2F;TinyWebServer: Linux下C++轻量级Web服务器学习 (github.com)</a></p>
<p>Linux下C++轻量级Web服务器<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>助力初学者快速实践网络编程<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>搭建属于自己的服务器.</p>
<ul>
<li>使用 <strong>线程池 + 非阻塞socket + epoll(ET和LT均实现) + 事件处理(Reactor和模拟Proactor均实现)</strong> 的并发模型</li>
<li>使用<strong>状态机</strong>解析HTTP请求报文<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>支持解析<strong>GET和POST</strong>请求</li>
<li>访问服务器数据库实现web端用户<strong>注册<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>登录</strong>功能<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以请求服务器<strong>图片和视频文件</strong></li>
<li>实现<strong>同步&#x2F;异步日志系统</strong><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>记录服务器运行状态</li>
<li>经Webbench压力测试可以实现<strong>上万的并发连接</strong>数据交换</li>
</ul>
<h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><h3 id="1-什么是Web-Server（网络服务器）"><a href="#1-什么是Web-Server（网络服务器）" class="headerlink" title="1. 什么是Web Server（网络服务器）?"></a>1. 什么是Web Server<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>网络服务器<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>?</h3><p>一个Web Server就是一个服务器软件<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>程序<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>或者是运行这个服务器软件的硬件<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>计算机<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>其主要功能是通过HTTP协议与客户端<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>通常是浏览器<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>Browser<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>进行通信<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>来接收<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>存储<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>处理来自客户端的HTTP请求<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并对其请求做出HTTP响应<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>返回给客户端其请求的内容<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>文件<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>网页等<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>或返回一个Error信息<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><img src="/img/loading.gif" data-original="images/Pasted%20image%2020230403145708.png"></p>
<h3 id="2-用户如何与你的Web服务器进行通信"><a href="#2-用户如何与你的Web服务器进行通信" class="headerlink" title="2. 用户如何与你的Web服务器进行通信?"></a>2. 用户如何与你的Web服务器进行通信?</h3><p>通常用户使用Web浏览器与相应服务器进行通信<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>在浏览器中键入<span class="bd-box"><h-char class="bd bd-end"><h-inner>“</h-inner></h-char></span>域名<span class="bd-box"><h-char class="bd bd-beg"><h-inner>”</h-inner></h-char></span>或<span class="bd-box"><h-char class="bd bd-end"><h-inner>“</h-inner></h-char></span>IP地址:端口号<span class="bd-box"><h-char class="bd bd-beg"><h-inner>”</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>浏览器则先将你的域名解析成相应的IP地址或者直接根据你的IP地址向对应的Web服务器发送一个HTTP请求<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这一过程首先要通过TCP协议的三次握手建立与目标Web服务器的连接<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>然后HTTP协议生成针对目标Web服务器的HTTP请求报文<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>通过TCP<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>IP等协议发送到目标Web服务器上<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h3 id="3-Web服务器如何接收客户端发来的HTTP请求报文呢"><a href="#3-Web服务器如何接收客户端发来的HTTP请求报文呢" class="headerlink" title="3. Web服务器如何接收客户端发来的HTTP请求报文呢?"></a>3. Web服务器如何接收客户端发来的HTTP请求报文呢?</h3><h4 id="什么是socket"><a href="#什么是socket" class="headerlink" title="什么是socket?"></a>什么是socket?</h4><p><strong>Web服务器端通过<code>socket</code>监听来自用户的请求<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></strong></p>
<pre><code class="c++">#include &lt;sys/socket.h&gt;  
#include &lt;netinet/in.h&gt;  
/* 创建监听socket文件描述符 */  
int listenfd = socket(PF_INET, SOCK_STREAM, 0);  
/* 创建监听socket的TCP/IP的IPV4 socket地址 */  
struct sockaddr_in address;  
bzero(&amp;address, sizeof(address));  
address.sin_family = AF_INET;  
address.sin_addr.s_addr = htonl(INADDR_ANY);  /* INADDR_ANY&lt;span class=&quot;bd-box&quot;&gt;&lt;h-char class=&quot;bd bd-beg&quot;&gt;&lt;h-inner&gt;：&lt;/h-inner&gt;&lt;/h-char&gt;&lt;/span&gt;将套接字绑定到所有可用的接口 */  
address.sin_port = htons(port);

int flag = 1;  
/* SO_REUSEADDR 允许端口被重复使用 */  
setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;flag, sizeof(flag));  
/* 绑定socket和它的地址 */  
ret = bind(listenfd, (struct sockaddr*)&amp;address, sizeof(address));    
/* 创建监听队列以存放待处理的客户连接&lt;span class=&quot;bd-box&quot;&gt;&lt;h-char class=&quot;bd bd-beg&quot;&gt;&lt;h-inner&gt;，&lt;/h-inner&gt;&lt;/h-char&gt;&lt;/span&gt;在这些客户连接被accept()之前 */  
ret = listen(listenfd, 5);
</code></pre>
<p>远端的很多用户会尝试去<code>connect()</code>这个Web Server上正在<code>listen</code>的这个<code>port</code><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而监听到的这些连接会排队等待被<code>accept()</code><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>由于用户连接请求是随机到达的异步事件<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>每当监听socket<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span><code>listenfd</code><span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span><code>listen</code>到新的客户连接并且放入监听队列<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们都需要告诉我们的Web服务器有连接来了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><code>accept</code>这个连接<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并分配一个逻辑单元来处理这个用户请求<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h4 id="什么是EPOLL-I-x2F-O复用"><a href="#什么是EPOLL-I-x2F-O复用" class="headerlink" title="什么是EPOLL I&#x2F;O复用?"></a>什么是EPOLL I&#x2F;O复用?</h4><p>参考: <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/92865868">浅谈Linux IO复用 - 知乎 (zhihu.com)</a></p>
<p>IO复用<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>I&#x2F;O Multiplexing<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>通俗的来说<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>是<strong>同时处理多个描述符IO事件的一种技术手段</strong><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这些文件描述符包括<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>socket套接字<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>普通文件<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>设备文件等<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>举个简单例子<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>tcp server同时处理两个文件描述符<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>一个是标准输入<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>一个是tcp连接<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>当server接收标准输入时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可能会因调用<code>fgets()</code>而阻塞<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>从而无法及时处理另一个tcp连接的可读事件<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>比如有tcp client发送了数据<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>如果tcp server想要同时处理多个描述符的事件<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可能的做法是开启多个线程或进程<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>各自等待描述符的可读可写事件<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>但这样一来<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>就需要引入线程间同步和通信问题<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>大大增加编程的复杂性<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>但IO复用技术的出现<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以很好的解决上述问题<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>它直接管理多个描述符<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>选出IO事件ready的描述符列表<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这种操作方式允许应用程序以较低的成本<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>较高的效率<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>同时管理多个描述符的IO事件<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>我们在处理用户请求的同时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>还需要继续监听其他客户的请求并分配其另一逻辑单元来处理<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>并发<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>同时处理多个事件<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>后面会提到使用线程池实现并发<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><strong>这里<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>服务器通过</strong>epoll<strong>这种I&#x2F;O复用技术<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>还有select和poll<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>来实现对监听socket<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span><code>listenfd</code><span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>和连接socket<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>客户请求<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>的同时监听<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></strong> 注意I&#x2F;O复用虽然可以同时监听多个文件描述符<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>但是它本身是阻塞的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并且当有多个文件描述符同时就绪的时候<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果不采取额外措施<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>程序则只能按顺序处理其中就绪的每一个文件描述符<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以为提高效率<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们将在这部分通过线程池来实现并发<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>多线程并发<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>为每个就绪的文件描述符分配一个逻辑单元<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>线程<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>来处理<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><strong>服务器程序通常需要处理三类事件<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>I&#x2F;O事件<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>信号及定时事件<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>有两种事件处理模式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></strong></p>
<ul>
<li>Reactor模式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>要求主线程<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>I&#x2F;O处理单元<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>只负责监听文件描述符上是否有事件发生<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>可读<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>可写<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>若有<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则立即通知工作线程<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>逻辑单元<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>将socket可读可写事件放入请求队列<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>交给工作线程处理<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li>
<li>Proactor模式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>将所有的I&#x2F;O操作都交给主线程和内核来处理<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>进行读<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>写<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>工作线程仅负责处理逻辑<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如主线程读完成后<code>users[sockfd].read()</code><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>选择一个工作线程来处理客户请求<code>pool-&gt;append(users + sockfd)</code><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li>
</ul>
<p>通常使用同步I&#x2F;O模型<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>如<code>epoll_wait</code><span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>实现Reactor<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>使用异步I&#x2F;O<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>如<code>aio_read</code>和<code>aio_write</code><span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>实现Proactor<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>在此项目中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们使用的是<strong>同步I&#x2F;O模拟的Proactor</strong>事件处理模式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><strong>Linux下有三种IO复用方式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>epoll<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>select和poll<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>为什么用epoll<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>它和其他两个有什么区别呢<span class="bd-box"><h-char class="bd bd-beg"><h-inner>？</h-inner></h-char></span></strong></p>
<ul>
<li>对于select和poll来说<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所有文件描述符都是在用户态被加入其文件描述符集合的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>每次调用都需要将整个集合拷贝到内核态<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>epoll则将整个文件描述符集合维护在内核态<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>每次添加文件描述符的时候都需要执行一个系统调用<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>系统调用的开销是很大的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而且在有很多短期活跃连接的情况下<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>epoll可能会慢于select和poll由于这些大量的系统调用开销<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li>
<li>select使用线性表描述文件描述符集合<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>文件描述符有上限<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>poll使用链表来描述<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>epoll底层通过红黑树来描述<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并且维护一个ready list<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>将事件表中已经就绪的事件添加到这里<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>在使用epoll_wait调用时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>仅观察这个list中有没有数据即可<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li>
<li>select和poll的最大开销来自内核判断是否有文件描述符就绪这一过程<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>每次执行select或poll调用时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>它们会采用遍历的方式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>遍历整个文件描述符集合去判断各个文件描述符是否有活动<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>epoll则不需要去以这种方式检查<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>当有活动产生时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>会自动触发epoll回调函数通知epoll文件描述符<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>然后内核将这些就绪的文件描述符放到之前提到的ready list中等待epoll_wait调用后被处理<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li>
<li>select和poll都只能工作在相对低效的LT模式下<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而epoll同时支持LT和ET模式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li>
<li>综上<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>当监测的fd数量较小<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>且各个fd都很活跃的情况下<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>建议使用select和poll<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>当监听的fd数量较多<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>且单位时间仅部分fd活跃的情况下<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>使用epoll会明显提升性能<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li>
</ul>
<p>从工作原理中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>也可以看出select与epoll的诸多不同<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><br>优缺点对比如下<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<ul>
<li>支持监听的描述符数量</li>
<li>select支持的描述符数量受限<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>因为需要遍历描述符列表<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>多次用户空间到内核空间的内存拷贝<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li>
<li>epoll可以支撑监听海量的描述符<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><br>性能</li>
<li>select随着描述符数量的增多<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>性能下降严重<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>时间复杂度 &gt; O(n)<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li>
<li>epoll通过回调函数的方式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>在描述符增长的情况下<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>依旧有出色的性能<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><br>使用场景</li>
<li>select使用方式较为简单<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>适用于描述符量级小的情况<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li>
<li>epoll适用于同时监听大量的描述符<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li>
</ul>
<p><strong><code>Epoll</code>对文件操作符的操作有两种模式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>LT<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>电平触发<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>和ET<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>边缘触发<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>二者的区别?</strong> </p>
<ul>
<li>LT<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>水平触发<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>默认<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>当时间发生时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果用户不处理的话<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>内核会一直通知此事件<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li>
<li>ET<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>垂直触发<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>只有当事件状态发生改变时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>内核才会通知<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>如果描述符缓冲区还有未处理的数据<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>内核下次不会再通知了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因为状态没有发生改变<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span></li>
</ul>
<h3 id="4-Web服务器如何处理以及响应接收到的HTTP请求报文呢"><a href="#4-Web服务器如何处理以及响应接收到的HTTP请求报文呢" class="headerlink" title="4. Web服务器如何处理以及响应接收到的HTTP请求报文呢?"></a>4. Web服务器如何处理以及响应接收到的HTTP请求报文呢?</h3><p>参考: <a target="_blank" rel="noopener" href="https://wangpengcheng.github.io/2019/05/17/cplusplus_theadpool/">C++ 线程池 - 敬方的个人博客 | BY Blog (wangpengcheng.github.io)</a></p>
<p><strong>该项目使用线程池<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>半同步半反应堆模式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>并发处理用户请求<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>主线程负责读写<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>工作线程<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>线程池中的线程<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>负责处理逻辑<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>HTTP请求报文的解析等等<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></strong> 通过之前的代码<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们将<code>listenfd</code>上到达的<code>connection</code>通过 <code>accept()</code>接收<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并返回一个新的socket文件描述符<code>connfd</code>用于和用户通信<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并对用户请求返回响应<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>同时将这个<code>connfd</code>注册到内核事件表中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>等用户发来请求报文<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h4 id="什么是线程池"><a href="#什么是线程池" class="headerlink" title="什么是线程池?"></a>什么是线程池?</h4><p>这个过程是<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>通过<code>epoll_wait</code>发现这个<code>connfd</code>上有可读事件了<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span><code>EPOLLIN</code><span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>主线程就将这个HTTP的请求报文读进这个连接socket的读缓存中<code>users[sockfd].read()</code><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>然后将该任务对象<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>指针<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>插入线程池的请求队列中<code>pool-&gt;append(users + sockfd);</code><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>线程池的实现还需要依靠<strong>锁机制</strong>以及<strong>信号量</strong>机制来实现线程同步<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>保证操作的原子性<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<ul>
<li>所谓线程池<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>就是一个<code>pthread_t</code>类型的普通数组<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>通过<code>pthread_create()</code>函数创建<code>m_thread_number</code>个<strong>线程</strong><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>用来执行<code>worker()</code>函数以执行每个请求处理函数<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>HTTP请求的<code>process</code>函数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>通过<code>pthread_detach()</code>将线程设置成脱离态<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>detached<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>后<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>当这一线程运行结束时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>它的资源会被系统自动回收<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而不再需要在其它线程中对其进行 <code>pthread_join()</code> 操作<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li>
<li>操作工作队列一定要加锁<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span><code>locker</code><span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因为它被所有线程共享<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li>
<li>我们用信号量来标识请求队列中的请求数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>通过<code>m_queuestat.wait();</code>来等待一个请求队列中待处理的HTTP请求<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>然后交给线程池中的空闲线程来处理<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li>
</ul>
<h4 id="为什么要使用线程池"><a href="#为什么要使用线程池" class="headerlink" title="为什么要使用线程池?"></a>为什么要使用线程池?</h4><p>当你需要限制你应用程序中同时运行的线程数时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>线程池非常有用<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>因为启动一个新线程会带来性能开销<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>每个线程也会为其堆栈分配一些内存等<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>为了任务的并发执行<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们可以将这些任务任务传递到线程池<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而不是为每个任务动态开启一个新的线程<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h4 id="关于HTTP请求"><a href="#关于HTTP请求" class="headerlink" title="关于HTTP请求?"></a>关于HTTP请求?</h4><p><strong>本项目中的HTTP请求的入口函数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></strong></p>
<pre><code class="c++">void http_conn::process() &#123;  
    HTTP_CODE read_ret = process_read();  
    if(read_ret == NO_REQUEST) &#123;  
        modfd(m_epollfd, m_sockfd, EPOLLIN);  
        return;  
    &#125;  
    bool write_ret = process_write(read_ret);  
    if(!write_ret)  
        close_conn();  
    modfd(m_epollfd, m_sockfd, EPOLLOUT);  
&#125;
</code></pre>
<p><strong>HTTP请求报文由请求行<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>request line<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>请求头部<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>header<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>空行和请求数据四个部分组成有<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>两种请求报文</strong></p>
<ul>
<li><strong>GET</strong><span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>Example<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span></li>
</ul>
<pre><code>GET /562f25980001b1b106000338.jpg HTTP/1.1  
Host:img.mukewang.com  
User-Agent:Mozilla/5.0 (Windows NT 10.0; WOW64)  
AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.106 Safari/537.36  
Accept:image/webp,image/*,*/*;q=0.8  
Referer:[http://www.imooc.com/](http://www.imooc.com/)  
Accept-Encoding:gzip, deflate, sdch  
Accept-Language:zh-CN,zh;q=0.8  
空行  
请求数据为空
</code></pre>
<ul>
<li><strong>POST</strong><span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>Example<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>注意POST的请求内容不为空<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span></li>
</ul>
<pre><code>POST / HTTP1.1  
Host:www.wrox.com  
User-Agent:Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727; .NET CLR 3.0.04506.648; .NET CLR 3.5.21022)  
Content-Type:application/x-www-form-urlencoded  
Content-Length:40  
Connection: Keep-Alive  
空行  
name=Professional%20Ajax&amp;publisher=Wiley
</code></pre>
<p><strong>GET和POST的区别</strong></p>
<ul>
<li>最直观的区别就是GET把参数包含在URL中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>POST通过request body传递参数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li>
<li>GET请求参数会被完整保留在浏览器历史记录里<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而POST中的参数不会被保留<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li>
<li>GET请求在URL中传送的参数是有长度限制<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>大多数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>浏览器通常都会限制url长度在2K个字节<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>大多数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>服务器最多处理64K大小的url<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li>
<li>GET产生一个TCP数据包<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>POST产生两个TCP数据包<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>对于GET方式的请求<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>浏览器会把http header和data一并发送出去<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>服务器响应200<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>返回数据<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>而对于POST<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>浏览器先发送header<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>服务器响应100<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>指示信息—表示请求已接收<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>继续处理<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>continue<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>浏览器再发送data<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>服务器响应200 ok<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>返回数据<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li>
</ul>
<p><code>process_read()</code>函数的作用就是将类似上述例子的请求报文进行解析<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因为用户的请求内容包含在这个请求报文里面<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>只有通过解析<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>知道用户请求的内容是什么<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>是请求图片<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>还是视频<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>或是其他请求<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们根据这些请求返回相应的HTML页面等<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>项目中使用<strong>主从状态机</strong>的模式进行解析<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>从状态机<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span><code>parse_line</code><span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>负责读取报文的一行<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>主状态机负责对该行数据进行解析<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>主状态机内部调用从状态机<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>从状态机驱动主状态机<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>每解析一部分都会将整个请求的<code>m_check_state</code>状态改变<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>状态机也就是根据这个状态来进行不同部分的解析跳转的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<ul>
<li><code>parse_request_line(text)</code><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>解析请求行<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>也就是GET中的<code>GET /562f25980001b1b106000338.jpg HTTP/1.1</code>这一行<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>或者POST中的<code>POST / HTTP1.1</code>这一行<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>通过请求行的解析我们可以判断该HTTP请求的类型<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>GET&#x2F;POST<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而请求行中最重要的部分就是<code>URL</code>部分<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们会将这部分保存下来用于后面的生成HTTP响应<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li>
<li><code>parse_headers(text);</code><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>解析请求头部<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>GET和POST中<code>空行</code>以上<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>请求行以下的部分<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li>
<li><code>parse_content(text);</code><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>解析请求数据<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>对于GET来说这部分是空的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因为这部分内容已经以明文的方式包含在了请求行中的<code>URL</code>部分了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>只有POST的这部分是有数据的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>项目中的这部分数据为用户名和密码<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们会根据这部分内容做登录和校验<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并涉及到与数据库的连接<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li>
</ul>
<h3 id="5-数据库连接池是如何运行的"><a href="#5-数据库连接池是如何运行的" class="headerlink" title="5. 数据库连接池是如何运行的?"></a>5. 数据库连接池是如何运行的?</h3><p>在处理用户注册<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>登录请求的时候<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们需要将这些用户的用户名和密码保存下来用于新用户的注册及老用户的登录校验<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这种功能是服务器端通过用户键入的用户名密码和数据库中已记录下来的用户名密码数据进行校验实现的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>若每次用户请求我们都需要新建一个数据库连接<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>请求结束后我们释放该数据库连接<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>当用户请求连接过多时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这种做法过于低效<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以类似<strong>线程池</strong>的做法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们构建一个数据库连接池<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>预先生成一些数据库连接放在那里供用户请求使用<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>我们首先看单个数据库连接是如何生成的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<ol>
<li>使用<code>mysql_init()</code>初始化连接</li>
<li>使用<code>mysql_real_connect()</code>建立一个到mysql数据库的连接</li>
<li>使用<code>mysql_query()</code>执行查询语句</li>
<li>使用<code>result = mysql_store_result(mysql)</code>获取结果集</li>
<li>使用<code>mysql_num_fields(result)</code>获取查询的列数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><code>mysql_num_rows(result)</code>获取结果集的行数</li>
<li>通过<code>mysql_fetch_row(result)</code>不断获取下一行<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>然后循环输出</li>
<li>使用<code>mysql_free_result(result)</code>释放结果集所占内存</li>
<li>使用<code>mysql_close(conn)</code>关闭连接</li>
</ol>
<p>对于一个数据库连接池来讲<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>就是预先生成多个这样的数据库连接<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>然后放在一个链表中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>同时维护最大连接数<code>MAX_CONN</code><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>当前可用连接数<code>FREE_CONN</code>和当前已用连接数<code>CUR_CONN</code>这三个变量<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>同样注意在对连接池操作时<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>获取<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>释放<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>要用到锁机制<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因为它被所有线程共享<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h3 id="6-什么是CGI校验"><a href="#6-什么是CGI校验" class="headerlink" title="6. 什么是CGI校验?"></a>6. 什么是CGI校验?</h3><p>OK<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>弄清楚了数据库连接池的概念及实现方式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们继续回到第4部分<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>对用户的登录及注册等POST请求<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>服务器是如何做校验的</p>
<p>CGI<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>通用网关接口<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>它是一个运行在Web服务器上的程序<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>在编译的时候将相应的<code>.cpp</code>文件编程成<code>.cgi</code>文件并在主程序中调用即可<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>通过社长的<code>makefile</code>文件内容也可以看出<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这些CGI程序通常通过客户在其浏览器上点击一个<code>button</code>时运行<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这些程序通常用来执行一些信息搜索<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>存储等任务<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而且通常会生成一个动态的HTML网页来响应客户的HTTP请求<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>我们可以发现项目中的<code>sign.cpp</code>文件就是我们的CGI程序<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>将用户请求中的用户名和密码保存在一个<code>id_passwd.txt</code>文件中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>通过将数据库中的用户名和密码存到一个<code>map</code>中用于校验<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>在主程序中通过<code>execl(m_real_file, &amp;flag, name, password, NULL);</code>这句命令来执行这个CGI文件<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这里CGI程序仅用于校验<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并未直接返回给用户响应<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这个CGI程序的运行通过多进程来实现<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>根据其返回结果判断校验结果<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>使用<code>pipe</code>进行父子进程的通信<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>子进程将校验结果写到pipe的写端<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>父进程在读端读取<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h3 id="7-如何生成HTTP响应并返回给用户"><a href="#7-如何生成HTTP响应并返回给用户" class="headerlink" title="7. 如何生成HTTP响应并返回给用户?"></a>7. 如何生成HTTP响应并返回给用户?</h3><p>通过以上操作<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们已经对读到的请求做好了处理<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>然后也对目标文件的属性作了分析<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>若目标文件存在<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>对所有用户可读且不是目录时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则使用<code>mmap</code>将其映射到内存地址<code>m_file_address</code>处<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并告诉调用者获取文件成功<code>FILE_REQUEST</code><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span> 接下来要做的就是根据读取结果对用户做出响应了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>也就是到了<code>process_write(read_ret);</code>这一步<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>该函数根据<code>process_read()</code>的返回结果来判断应该返回给用户什么响应<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们最常见的就是<code>404</code>错误了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>说明客户请求的文件不存在<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>除此之外还有其他类型的请求出错的响应<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>具体的可以去百度<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>然后呢<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>假设用户请求的文件存在<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而且已经被<code>mmap</code>到<code>m_file_address</code>这里了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么我们就将做如下写操作<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>将响应写到这个<code>connfd</code>的写缓存<code>m_write_buf</code>中去</p>
<pre><code class="c++">case FILE_REQUEST: &#123;  
    add_status_line(200, ok_200_title);  
    if(m_file_stat.st_size != 0) &#123;  
        add_headers(m_file_stat.st_size);  
        m_iv[0].iov_base = m_write_buf;  
        m_iv[0].iov_len = m_write_idx;  
        m_iv[1].iov_base = m_file_address;  
        m_iv[1].iov_len = m_file_stat.st_size;  
        m_iv_count = 2;  
        bytes_to_send = m_write_idx + m_file_stat.st_size;  
        return true;  
    &#125;  
    else &#123;  
        const char* ok_string = &quot;&lt;html&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;&quot;;  
        add_headers(strlen(ok_string));  
        if(!add_content(ok_string))  
            return false;  
    &#125;  
&#125;
</code></pre>
<h2 id="00-Linux网络开发环境搭建"><a href="#00-Linux网络开发环境搭建" class="headerlink" title="00 Linux网络开发环境搭建"></a>00 Linux网络开发环境搭建</h2><p>MacOS虽然也是UNIX操作系统, 但本项目中的许多库函数在Mac下并未得到支持, 所以本次项目使用Docker下的虚拟环境进行开发.</p>
<pre><code class="sh">#macos
docker pull centos
docker -it run centos

#centos container
yum update -y
yum install gcc-c++
yum install mysql
yum install mysql-server

ln -s /usr/lib64/libmysqlclient.so /usr/lib/libmysqlclient.so
</code></pre>
<h2 id="01-线程同步机制封装类"><a href="#01-线程同步机制封装类" class="headerlink" title="01 线程同步机制封装类"></a>01 线程同步机制封装类</h2><h4 id="C-的RSII机制"><a href="#C-的RSII机制" class="headerlink" title="C++的RSII机制"></a>C++的RSII机制</h4><ul>
<li>RAII全称是<span class="bd-box"><h-char class="bd bd-end"><h-inner>“</h-inner></h-char></span>Resource Acquisition is Initialization<span class="bd-box"><h-char class="bd bd-beg"><h-inner>”</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>直译过来是<span class="bd-box"><h-char class="bd bd-end"><h-inner>“</h-inner></h-char></span>资源获取即初始化<span class="bd-box"><h-char class="bd bd-beg"><h-inner>”</h-inner></h-char></span>.</li>
<li>在构造函数中申请分配资源<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>在析构函数中释放资源<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>因为C++的语言机制保证了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>当一个对象创建的时候<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>自动调用构造函数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>当对象超出作用域的时候会自动调用析构函数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>所以<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>在RAII的指导下<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们应该使用类来管理资源<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>将资源和对象的生命周期绑定</li>
<li>RAII的核心思想是将资源或者状态与对象的生命周期绑定<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>通过C++的语言机制<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>实现资源和状态的安全管理,智能指针是RAII最好的例子</li>
</ul>
<h4 id="Linux中的条件变量"><a href="#Linux中的条件变量" class="headerlink" title="Linux中的条件变量"></a>Linux中的条件变量</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/hmxz2nn/article/details/80786188"> linux中的条件变量的使用-CSDN博客</a></p>
<p>条件变量提供了一种线程间的通知机制,当某个共享数据达到某个值时,唤醒等待这个共享数据的线程.</p>
<blockquote>
<ul>
<li><p>pthread_cond_init函数用于初始化条件变量</p>
</li>
<li><p>pthread_cond_destory函数销毁条件变量</p>
</li>
<li><p>pthread_cond_broadcast函数以广播的方式唤醒<strong>所有</strong>等待目标条件变量的线程</p>
</li>
<li><p>pthread_cond_wait函数用于等待目标条件变量.该函数调用时需要传入 <strong>mutex参数(加锁的互斥锁)</strong> ,函数执行时,先把调用线程放入条件变量的请求队列,然后将互斥锁mutex解锁,当函数成功返回为0时,互斥锁会再次被锁上. <strong>也就是说函数内部会有一次解锁和加锁操作</strong>.</p>
</li>
</ul>
</blockquote>
<h4 id="Linux中的互斥量"><a href="#Linux中的互斥量" class="headerlink" title="Linux中的互斥量"></a>Linux中的互斥量</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/zmxiangde_88/article/details/7998458">Linux线程-互斥锁-CSDN博客</a></p>
<p>互斥锁,也成互斥量,可以保护关键代码段,以确保独占式访问.当进入关键代码段,获得互斥锁将其加锁;离开关键代码段,唤醒等待该互斥锁的线程.</p>
<blockquote>
<ul>
<li><p>pthread_mutex_init函数用于初始化互斥锁</p>
</li>
<li><p>pthread_mutex_destory函数用于销毁互斥锁</p>
</li>
<li><p>pthread_mutex_lock函数以原子操作方式给互斥锁加锁</p>
</li>
<li><p>pthread_mutex_unlock函数以原子操作方式给互斥锁解锁</p>
</li>
</ul>
</blockquote>
<p>以上<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>成功返回0<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>失败返回errno</p>
<h4 id="Linux中的信号量"><a href="#Linux中的信号量" class="headerlink" title="Linux中的信号量"></a>Linux中的信号量</h4><p>信号量是一种特殊的变量<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>它只能取自然数值并且只支持两种操作<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>等待(P)和信号(V).假设有信号量SV<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>对其的P<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>V操作如下<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<ul>
<li>P<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果SV的值大于0<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则将其减一<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>若SV的值为0<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则挂起执行</li>
<li>V<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果有其他进行因为等待SV而挂起<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则唤醒<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>若没有<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则将SV值加一</li>
</ul>
<p>信号量的取值可以是任何自然数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>最常用的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>最简单的信号量是二进制信号量<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>只有0和1两个值.</p>
<blockquote>
<ul>
<li><p>sem_init函数用于初始化一个未命名的信号量</p>
</li>
<li><p>sem_destory函数用于销毁信号量</p>
</li>
<li><p>sem_wait函数将以原子操作方式将信号量减一,信号量为0时,sem_wait阻塞</p>
</li>
<li><p>sem_post函数以原子操作方式将信号量加一,信号量大于0时,唤醒调用sem_post的线程</p>
</li>
</ul>
</blockquote>
<p>以上<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>成功返回0<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>失败返回errno</p>
<h2 id="02-数据库连接池"><a href="#02-数据库连接池" class="headerlink" title="02 数据库连接池"></a>02 数据库连接池</h2><p><strong>什么是数据库连接池<span class="bd-box"><h-char class="bd bd-beg"><h-inner>？</h-inner></h-char></span></strong></p>
<p>池是一组资源的集合<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这组资源在服务器启动之初就被完全创建好并初始化<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>通俗来说<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>池是资源的容器<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>本质上是对资源的复用<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>顾名思义<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>连接池中的资源为一组数据库连接<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>由程序动态地对池中的连接进行使用<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>释放<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>当系统开始处理客户请求的时候<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果它需要相关的资源<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以直接从池中获取<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>无需动态分配<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>当服务器处理完一个客户连接后,可以把相关的资源放回池中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>无需执行系统调用释放资源<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><strong>数据库访问的一般流程是什么<span class="bd-box"><h-char class="bd bd-beg"><h-inner>？</h-inner></h-char></span></strong></p>
<p>当系统需要访问数据库时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>先系统创建数据库连接<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>完成数据库操作<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>然后系统断开数据库连接<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><strong>为什么要创建连接池<span class="bd-box"><h-char class="bd bd-beg"><h-inner>？</h-inner></h-char></span></strong></p>
<p>从一般流程中可以看出<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>若系统需要频繁访问数据库<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则需要频繁创建和断开数据库连接<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而创建数据库连接是一个很耗时的操作<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>也容易对数据库造成安全隐患<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>在程序初始化的时候<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>集中创建多个数据库连接<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并把他们集中管理<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>供程序使用<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以保证较快的数据库读写速度<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>更加安全可靠<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><strong>数据库连接池</strong></p>
<p>池可以看做资源的容器<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以多种实现方法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>比如数组<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>链表<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>队列等<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这里<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>使用单例模式和链表创建数据库连接池<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>实现对数据库连接资源的复用<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>项目中的数据库模块分为两部分<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其一是数据库连接池的定义<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其二是利用连接池完成登录和注册的校验功能<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>具体的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>工作线程从数据库连接池取得一个连接<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>访问数据库中的数据<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>访问完毕后将连接交还连接池<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><strong>单例模式创建</strong><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>结合代码描述连接池的单例实现<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><strong>连接池代码实现</strong><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>结合代码对连接池的外部访问接口进行详解<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><strong>RAII机制释放数据库连接</strong><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>描述连接释放的封装逻辑<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>数据库连接池</p>
<blockquote>
<ul>
<li>单例模式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>保证唯一</li>
<li>list实现连接池</li>
<li>连接池为静态大小</li>
<li>互斥锁实现线程安全</li>
</ul>
</blockquote>
<ul>
<li>connectionRAII类</li>
</ul>
<pre><code class="c++">class connectionRAII&#123;
    public:
    connectionRAII(MYSQL **con, connection_pool *connPool);
    ~connectionRAII();

    private:
    MYSQL *conRAII;
    connection_pool *poolRAII;

&#125;;
</code></pre>
<p>目的是实现connction的自动连接与释放, 以下显示了connectionRAII在用户代码是如何被使用, 起到了怎样的效果</p>
<pre><code class="c++">//引入RAII类前: 用户代码中需要手动获得和释放连接
//从连接池中取出一个数据库连接  
request-&gt;mysql = m_connPool-&gt;GetConnection();  
//process(模板类中的方法,这里是http类)进行处理  
request-&gt;process();  
//将数据库连接放回连接池  
m_connPool-&gt;ReleaseConnection(request-&gt;mysql);

//引入RAII类之后: 连接不使用可以被自动释放
connectionRAII mysqlcon(&amp;request-&gt;mysql, m_connPool);
request-&gt;process();
</code></pre>
<h2 id="03-半同步半反应堆线程池"><a href="#03-半同步半反应堆线程池" class="headerlink" title="03 半同步半反应堆线程池"></a>03 半同步半反应堆线程池</h2><h4 id="服务器编程基本框架"><a href="#服务器编程基本框架" class="headerlink" title="服务器编程基本框架"></a>服务器编程基本框架</h4><p><img src="/img/loading.gif" data-original="images/Pasted%20image%2020230406113628.png"></p>
<p>主要由I&#x2F;O单元<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>逻辑单元和网络存储单元组成<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其中每个单元之间通过请求队列进行通信<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>从而协同完成任务<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>其中I&#x2F;O单元用于处理客户端连接<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>读写网络数据<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>逻辑单元用于处理业务逻辑的线程<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>网络存储单元指本地数据库和文件等<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h4 id="五种I-x2F-O模型"><a href="#五种I-x2F-O模型" class="headerlink" title="五种I&#x2F;O模型"></a>五种I&#x2F;O模型</h4><ul>
<li><p><strong>阻塞IO</strong>:调用者调用了某个函数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>等待这个函数返回<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>期间什么也不做<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>不停的去检查这个函数有没有返回<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>必须等这个函数返回才能进行下一步动作</p>
</li>
<li><p><strong>非阻塞IO</strong>:非阻塞等待<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>每隔一段时间就去检测IO事件是否就绪<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>没有就绪就可以做其他事<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>非阻塞I&#x2F;O执行系统调用总是立即返回<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>不管时间是否已经发生<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>若时间没有发生<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则返回-1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>此时可以根据errno区分这两种情况<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>对于accept<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>recv和send<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>事件未发生时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>errno通常被设置成eagain</p>
</li>
<li><p><strong>信号驱动IO</strong>:linux用套接口进行信号驱动IO<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>安装一个信号处理函数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>进程继续运行并不阻塞<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>当IO时间就绪<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>进程收到SIGIO信号<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>然后处理IO事件<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
</li>
<li><p><strong>IO复用</strong>:linux用select&#x2F;poll函数实现IO复用模型<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这两个函数也会使进程阻塞<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>但是和阻塞IO所不同的是这两个函数可以同时阻塞多个IO操作<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>而且可以同时对多个读操作<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>写操作的IO函数进行检测<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>知道有数据可读或可写时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>才真正调用IO操作函数</p>
</li>
<li><p><strong>异步IO</strong>:linux中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以调用aio_read函数告诉内核描述字缓冲区指针和缓冲区的大小<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>文件偏移及通知的方式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>然后立即返回<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>当内核将数据拷贝到缓冲区后<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>再通知应用程序<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
</li>
</ul>
<h4 id="事件处理模式"><a href="#事件处理模式" class="headerlink" title="事件处理模式"></a>事件处理模式</h4><ul>
<li><p>reactor模式中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>主线程(<strong>I&#x2F;O处理单元</strong>)只负责监听文件描述符上是否有事件发生<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>有的话立即通知工作线程(<strong>逻辑单元</strong> )<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>读写数据<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>接受新连接及处理客户请求均在工作线程中完成<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>通常由<strong>同步I&#x2F;O</strong>实现<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
</li>
<li><p>proactor模式中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>主线程和内核负责处理读写数据<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>接受新连接等I&#x2F;O操作<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>工作线程仅负责业务逻辑<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如处理客户请求<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>通常由<strong>异步I&#x2F;O</strong>实现<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
</li>
</ul>
<h4 id="同步I-x2F-O模拟proactor模式"><a href="#同步I-x2F-O模拟proactor模式" class="headerlink" title="同步I&#x2F;O模拟proactor模式"></a>同步I&#x2F;O模拟proactor模式</h4><p>由于异步I&#x2F;O并不成熟<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>实际中使用较少<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这里将使用同步I&#x2F;O模拟实现proactor模式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>同步I&#x2F;O模型的工作流程如下<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>epoll_wait为例<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<blockquote>
<ul>
<li><p>主线程往epoll内核事件表注册socket上的读就绪事件<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
</li>
<li><p>主线程调用epoll_wait等待socket上有数据可读</p>
</li>
<li><p>当socket上有数据可读<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>epoll_wait通知主线程,主线程从socket循环读取数据<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>直到没有更多数据可读<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>然后将读取到的数据封装成一个请求对象并插入请求队列<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
</li>
<li><p>睡眠在请求队列上某个工作线程被唤醒<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>它获得请求对象并处理客户请求<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>然后往epoll内核事件表中注册该socket上的写就绪事件</p>
</li>
<li><p>主线程调用epoll_wait等待socket可写<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
</li>
<li><p>当socket上有数据可写<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>epoll_wait通知主线程<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>主线程往socket上写入服务器处理客户请求的结果<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
</li>
</ul>
</blockquote>
<h4 id="并发编程模式"><a href="#并发编程模式" class="headerlink" title="并发编程模式"></a>并发编程模式</h4><p>并发编程方法的实现有多线程和多进程两种<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>但这里涉及的并发模式指I&#x2F;O处理单元与逻辑单元的协同完成任务的方法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<ul>
<li><p>半同步&#x2F;半异步模式</p>
</li>
<li><p>领导者&#x2F;追随者模式</p>
</li>
</ul>
<p><strong>半同步&#x2F;半反应堆并发模式是半同步&#x2F;半异步的变体<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>将半异步具体化为某种事件处理模式.</strong></p>
<p>并发模式中的同步和异步</p>
<blockquote>
<ul>
<li><p>同步指的是程序完全按照代码序列的顺序执行</p>
</li>
<li><p>异步指的是程序的执行需要由系统事件驱动</p>
</li>
</ul>
</blockquote>
<p>半同步&#x2F;半异步模式工作流程</p>
<blockquote>
<ul>
<li><p>同步线程用于处理客户逻辑</p>
</li>
<li><p>异步线程用于处理I&#x2F;O事件</p>
</li>
<li><p>异步线程监听到客户请求后<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>就将其封装成请求对象并插入请求队列中</p>
</li>
<li><p>请求队列将通知某个工作在<strong>同步模式的工作线程</strong>来读取并处理该请求对象</p>
</li>
</ul>
</blockquote>
<p>半同步&#x2F;半反应堆工作流程<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>以Proactor模式为例<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span></p>
<blockquote>
<ul>
<li><p>主线程充当异步线程<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>负责监听所有socket上的事件</p>
</li>
<li><p>若有新请求到来<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>主线程接收之以得到新的连接socket<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>然后往epoll内核事件表中注册该socket上的读写事件</p>
</li>
<li><p>如果连接socket上有读写事件发生<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>主线程从socket上接收数据<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并将数据封装成请求对象插入到请求队列中</p>
</li>
<li><p>所有工作线程(线程池)睡眠在请求队列上<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>当有任务到来时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>通过竞争<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>如互斥锁<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>获得任务的接管权</p>
</li>
</ul>
</blockquote>
<h4 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h4><ul>
<li><p>空间换时间,牺牲服务器的硬件资源,换取运行效率.</p>
</li>
<li><p>池是一组资源的集合,这组资源在服务器启动之初就被完全创建好并初始化,这称为静态资源.</p>
</li>
<li><p>当服务器进入正式运行阶段,开始处理客户请求的时候,如果它需要相关的资源,可以直接从池中获取,无需动态分配.</p>
</li>
<li><p>当服务器处理完一个客户连接后,可以把相关的资源放回池中,无需执行系统调用释放资源.</p>
</li>
</ul>
<h4 id="静态成员变量"><a href="#静态成员变量" class="headerlink" title="静态成员变量"></a>静态成员变量</h4><p>将类成员变量声明为static<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则为静态成员变量<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>与一般的成员变量不同<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>无论建立多少对象<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>都只有一个静态成员变量的拷贝<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>静态成员变量属于一个类<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所有对象共享<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>静态变量在编译阶段就分配了空间<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>对象还没创建时就已经分配了空间<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>放到全局静态区<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<ul>
<li><p>最好是类内声明<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>类外初始化<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>以免类名访问静态成员访问不到<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
</li>
<li><p>无论公有<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>私有<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>静态成员都可以在类外定义<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>但私有成员仍有访问权限<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
</li>
<li><p>非静态成员类外不能初始化<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
</li>
<li><p>静态成员数据是共享的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
</li>
</ul>
<h4 id="静态成员函数"><a href="#静态成员函数" class="headerlink" title="静态成员函数"></a>静态成员函数</h4><p>将类成员函数声明为static<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则为静态成员函数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<ul>
<li><p>静态成员函数可以直接访问静态成员变量<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>不能直接访问普通成员变量<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>但可以通过参数传递的方式访问<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
</li>
<li><p>普通成员函数可以访问普通成员变量<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>也可以访问静态成员变量<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
</li>
<li><p>静态成员函数没有this指针<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>非静态数据成员为对象单独维护<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>但静态成员函数为共享函数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>无法区分是哪个对象<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因此不能直接访问普通变量成员<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>也没有this指针<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
</li>
</ul>
<h4 id="pthread-create陷阱"><a href="#pthread-create陷阱" class="headerlink" title="pthread_create陷阱"></a>pthread_create陷阱</h4><pre><code class="c++">static void *worker(void *args);

pthread_create(m_threads[i], NULL, worker, this)!=0
</code></pre>
<p>首先看一下该函数的函数原型<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><br><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/8607.html">pthread_create()函数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>创建线程 (biancheng.net)</a></p>
<pre><code class="c++">int pthread_create(pthread_t *thread,
                   const pthread_attr_t *attr,
                   void *(*start_routine) (void *),
                   void *arg);
</code></pre>
<pre><code class="c++">pthread_create(m_threads[i], NULL, worker, this)!=0
//本质上工作线程的内容还是threadpool&lt;T&gt;::run()
template &lt;typename T&gt;
void *threadpool&lt;T&gt;::worker(void *arg)
&#123;
threadpool *pool = (threadpool *)arg;
pool-&gt;run();
return pool;
&#125;
</code></pre>
<p>函数原型中的第三个参数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>为函数指针<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>指向处理线程函数的地址<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>该函数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>要求为静态函数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>如果处理线程函数为类成员函数时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>需要将其设置为<strong>静态成员函数</strong><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><br>pthread_create的函数原型中第三个参数的类型为函数指针<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>指向的线程处理函数参数类型为<code>(void *)</code>,若线程函数为类成员函数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则this指针会作为默认的参数被传进函数中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>从而和线程函数参数<code>(void*)</code>不能匹配<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>不能通过编译<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>静态成员函数就没有这个问题<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>里面没有this指针<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h4 id="线程池设计"><a href="#线程池设计" class="headerlink" title="线程池设计"></a>线程池设计</h4><p>使用一个工作队列完全解除了主线程和工作线程的耦合关系<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>主线程往工作队列中插入任务<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>工作线程通过竞争来取得任务并执行它<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<blockquote>
<ul>
<li>同步I&#x2F;O模拟proactor模式</li>
<li>半同步&#x2F;半反应堆</li>
<li>线程池</li>
</ul>
</blockquote>
<p>线程池的设计模式为半同步&#x2F;半反应堆<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其中反应堆具体为Proactor事件处理模式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>具体的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>主线程为异步线程<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>负责监听文件描述符<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>接收socket新连接<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>若当前监听的socket发生了读写事件<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>然后将任务插入到请求队列<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>工作线程从请求队列中取出任务<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>完成读写数据的处理<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h2 id="04-HTTP连接处理"><a href="#04-HTTP连接处理" class="headerlink" title="04 HTTP连接处理"></a>04 HTTP连接处理</h2><h3 id="IO复用"><a href="#IO复用" class="headerlink" title="IO复用"></a>IO复用</h3><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/115220699">一文看懂IO多路复用 - 知乎 (zhihu.com)</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_39274501/article/details/114434382"><span class="bd-box"><h-char class="bd bd-end"><h-inner>《</h-inner></h-char></span>Linux高性能服务器编程<span class="bd-box"><h-char class="bd bd-beg"><h-inner>》</h-inner></h-char></span>第九章 I&#x2F;O复用-CSDN博客</a></p>
<p>epoll涉及的知识较多<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这里仅对API和基础知识作介绍<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>更多资料请查阅资料<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>或查阅<code>游双的Linux高性能服务器编程 第9章 I/O复用</code></p>
<h4 id="epoll-create函数"><a href="#epoll-create函数" class="headerlink" title="epoll_create函数"></a><strong>epoll_create函数</strong></h4><pre><code class="c++">#include &lt;sys/epoll.h&gt;
int epoll_create(int size)
</code></pre>
<p>创建一个指示epoll内核事件表的文件描述符<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>该描述符将用作其他epoll系统调用的第一个参数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>size不起作用<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h4 id="epoll-ctl函数"><a href="#epoll-ctl函数" class="headerlink" title="epoll_ctl函数"></a><strong>epoll_ctl函数</strong></h4><pre><code class="c++">#include &lt;sys/epoll.h&gt;
int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)
</code></pre>
<p>该函数用于操作内核事件表监控的文件描述符上的事件<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>注册<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>修改<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>删除</p>
<ul>
<li><p>epfd<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>为epoll_creat的句柄</p>
</li>
<li><p>op<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>表示动作<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>用3个宏来表示<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
</li>
<li><p>EPOLL_CTL_ADD (注册新的fd到epfd)<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span></p>
</li>
<li><p>EPOLL_CTL_MOD (修改已经注册的fd的监听事件)<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span></p>
</li>
<li><p>EPOLL_CTL_DEL (从epfd删除一个fd)<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span></p>
</li>
<li><p>event<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>告诉内核需要监听的事件</p>
</li>
</ul>
<p>上述event是epoll_event结构体指针类型<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>表示内核所监听的事件<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>具体定义如下<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<pre><code class="c++">struct epoll_event &#123;
__uint32_t events; /* Epoll events */
epoll_data_t data; /* User data variable */&#125;;
</code></pre>
<ul>
<li><p>events描述事件类型<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其中epoll事件类型有以下几种</p>
</li>
<li><p>EPOLLIN<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>表示对应的文件描述符可以读<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>包括对端SOCKET正常关闭<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span></p>
</li>
<li><p>EPOLLOUT<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>表示对应的文件描述符可以写</p>
</li>
<li><p>EPOLLPRI<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>表示对应的文件描述符有紧急的数据可读<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>这里应该表示有带外数据到来<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span></p>
</li>
<li><p>EPOLLERR<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>表示对应的文件描述符发生错误</p>
</li>
<li><p>EPOLLHUP<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>表示对应的文件描述符被挂断<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span></p>
</li>
<li><p>EPOLLET<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>将EPOLL设为边缘触发(Edge Triggered)模式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这是相对于水平触发(Level Triggered)而言的</p>
</li>
<li><p>EPOLLONESHOT<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>只监听一次事件<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>当监听完这次事件之后<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果还需要继续监听这个socket的话<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>需要再次把这个socket加入到EPOLL队列里</p>
</li>
</ul>
<h4 id="epoll-wait函数"><a href="#epoll-wait函数" class="headerlink" title="epoll_wait函数"></a><strong>epoll_wait函数</strong></h4><pre><code class="c++">#include &lt;sys/epoll.h&gt;
int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout)
</code></pre>
<p>该函数用于等待所监控文件描述符上有事件的产生<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>返回就绪的文件描述符个数</p>
<ul>
<li><p>events<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>用来存内核得到事件的集合<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span></p>
</li>
<li><p>maxevents<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>告之内核这个events有多大<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这个maxevents的值不能大于创建epoll_create()时的size<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span></p>
</li>
<li><p>timeout<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>是超时时间</p>
</li>
<li><p>-1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>阻塞</p>
</li>
<li><p>0<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>立即返回<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>非阻塞</p>
</li>
<li><blockquote>
<p>0<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>指定毫秒</p>
</blockquote>
</li>
<li><p>返回值<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>成功返回有多少文件描述符就绪<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>时间到时返回0<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>出错返回-1</p>
</li>
</ul>
<h4 id="select-x2F-poll-x2F-epoll"><a href="#select-x2F-poll-x2F-epoll" class="headerlink" title="select&#x2F;poll&#x2F;epoll"></a><strong>select&#x2F;poll&#x2F;epoll</strong></h4><ul>
<li><p>调用函数</p>
</li>
<li><p>select和poll都是一个函数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>epoll是一组函数</p>
</li>
<li><p>文件描述符数量</p>
</li>
<li><p>select通过线性表描述文件描述符集合<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>文件描述符有上限<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>一般是1024<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>但可以修改源码<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>重新编译内核<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>不推荐</p>
</li>
<li><p>poll是链表描述<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>突破了文件描述符上限<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>最大可以打开文件的数目</p>
</li>
<li><p>epoll通过红黑树描述<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>最大可以打开文件的数目<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以通过命令ulimit -n number修改<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>仅对当前终端有效</p>
</li>
<li><p>将文件描述符从用户传给内核</p>
</li>
<li><p>select和poll通过将所有文件描述符拷贝到内核态<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>每次调用都需要拷贝</p>
</li>
<li><p>epoll通过epoll_create建立一棵红黑树<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>通过epoll_ctl将要监听的文件描述符注册到红黑树上</p>
</li>
<li><p>内核判断就绪的文件描述符</p>
</li>
<li><p>select和poll通过遍历文件描述符集合<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>判断哪个文件描述符上有事件发生</p>
</li>
<li><p>epoll_create时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>内核除了帮我们在epoll文件系统里建了个红黑树用于存储以后epoll_ctl传来的fd外<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>还会再建立一个list链表<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>用于存储准备就绪的事件<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>当epoll_wait调用时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>仅仅观察这个list链表里有没有数据即可<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
</li>
<li><p>epoll是根据每个fd上面的回调函数(中断函数)判断<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>只有发生了事件的socket才会主动的去调用 callback函数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其他空闲状态socket则不会<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>若是就绪事件<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>插入list</p>
</li>
<li><p>应用程序索引就绪文件描述符</p>
</li>
<li><p>select&#x2F;poll只返回发生了事件的文件描述符的个数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>若知道是哪个发生了事件<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>同样需要遍历</p>
</li>
<li><p>epoll返回的发生了事件的个数和结构体数组<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>结构体包含socket的信息<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因此直接处理返回的数组即可</p>
</li>
<li><p>工作模式</p>
</li>
<li><p>select和poll都只能工作在相对低效的LT模式下</p>
</li>
<li><p>epoll则可以工作在ET高效模式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并且epoll还支持EPOLLONESHOT事件<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>该事件能进一步减少可读<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>可写和异常事件被触发的次数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span> </p>
</li>
<li><p>应用场景</p>
</li>
<li><p>当所有的fd都是活跃连接<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>使用epoll<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>需要建立文件系统<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>红黑书和链表对于此来说<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>效率反而不高<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>不如selece和poll</p>
</li>
<li><p>当监测的fd数目较小<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>且各个fd都比较活跃<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>建议使用select或者poll</p>
</li>
<li><p>当监测的fd数目非常大<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>成千上万<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>且单位时间只有其中的一部分fd处于就绪状态<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这个时候使用epoll能够明显提升性能</p>
</li>
</ul>
<h4 id="ET、LT、EPOLLONESHOT"><a href="#ET、LT、EPOLLONESHOT" class="headerlink" title="ET、LT、EPOLLONESHOT"></a><strong>ET<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>LT<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>EPOLLONESHOT</strong></h4><ul>
<li><p>LT水平触发模式</p>
</li>
<li><p>epoll_wait检测到文件描述符有事件发生<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则将其通知给应用程序<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>应用程序可以不立即处理该事件<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
</li>
<li><p>当下一次调用epoll_wait时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>epoll_wait还会再次向应用程序报告此事件<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>直至被处理</p>
</li>
<li><p>ET边缘触发模式</p>
</li>
<li><p>epoll_wait检测到文件描述符有事件发生<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则将其通知给应用程序<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>应用程序必须立即处理该事件</p>
</li>
<li><p>必须要一次性将数据读取完<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>使用非阻塞I&#x2F;O<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>读取到出现eagain</p>
</li>
<li><p>EPOLLONESHOT</p>
</li>
<li><p>一个线程读取某个socket上的数据后开始处理数据<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>在处理过程中该socket上又有新数据可读<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>此时另一个线程被唤醒读取<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>此时出现两个线程处理同一个socket</p>
</li>
<li><p>我们期望的是一个socket连接在任一时刻都只被一个线程处理<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>通过epoll_ctl对该文件描述符注册epolloneshot事件<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>一个线程处理socket时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其他线程将无法处理<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><strong>当该线程处理完后<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>需要通过epoll_ctl重置epolloneshot事件</strong></p>
</li>
</ul>
<h3 id="HTTP报文"><a href="#HTTP报文" class="headerlink" title="HTTP报文"></a>HTTP报文</h3><p>HTTP报文分为请求报文和响应报文两种<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>每种报文必须按照特有格式生成<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>才能被浏览器端识别<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><br>其中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>浏览器端向服务器发送的为请求报文<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>服务器处理后返回给浏览器端的为响应报文<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h4 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a><strong>请求报文</strong></h4><p>HTTP请求报文由请求行<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>request line<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>请求头部<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>header<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>空行和请求数据四个部分组成<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><br>其中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>请求分为两种<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>GET和POST<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>具体的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<ul>
<li><strong>GET</strong></li>
</ul>
<pre><code>1    GET /562f25980001b1b106000338.jpg HTTP/1.1 
2    Host:img.mukewang.com 
3    User-Agent:Mozilla/5.0 (Windows NT 10.0; WOW64) 4    AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.106 Safari/537.36 5    Accept:image/webp,image/*,*/*;q=0.8 
6    Referer:http://www.imooc.com/ 
7    Accept-Encoding:gzip, deflate, sdch 
8    Accept-Language:zh-CN,zh;q=0.8 9    空行10    请求数据为空
</code></pre>
<ul>
<li><strong>POST</strong></li>
</ul>
<pre><code>1    POST / HTTP1.1
2    Host:www.wrox.com
3    UserAgent:Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727; .NET CLR 3.0.04506.648; .NET CLR 3.5.21022)
4    Content-Type:application/x-www-form-urlencoded
5    Content-Length:40
6    Connection: Keep-Alive
7    空行
8    name=Professional%20Ajax&amp;publisher=Wiley
</code></pre>
<h4 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a><strong>响应报文</strong></h4><p>HTTP响应也由四个部分组成<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>分别是<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>状态行<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>消息报头<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>空行和响应正文<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<pre><code>1 HTTP/1.1 200 OK 
2 Date: Fri, 22 May 2009 06:07:21 GMT 
3 Content-Type: text/html; charset=UTF-8 
4 空行 
5&lt;html&gt; 
6&lt;head&gt;&lt;/head&gt; 
7      &lt;body&gt; 
8            &lt;!--body goes here--&gt; 
9      &lt;/body&gt;
10&lt;/html&gt;
</code></pre>
<blockquote>
<ul>
<li><p>状态行<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>由HTTP协议版本号<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span> 状态码<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span> 状态消息 三部分组成<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><br>第一行为状态行<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>HTTP&#x2F;1.1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>表明HTTP版本为1.1版本<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>状态码为200<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>状态消息为OK<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
</li>
<li><p>消息报头<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>用来说明客户端要使用的一些附加信息<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><br>第二行和第三行为消息报头<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>Date:生成响应的日期和时间<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>Content-Type:指定了MIME类型的HTML(text&#x2F;html),编码类型是UTF-8<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
</li>
<li><p>空行<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>消息报头后面的空行是必须的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
</li>
<li><p>响应正文<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>服务器返回给客户端的文本信息<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>空行后面的html部分为响应正文<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
</li>
</ul>
</blockquote>
<h4 id="响应状态码"><a href="#响应状态码" class="headerlink" title="响应状态码"></a>响应状态码</h4><p>HTTP有5种类型的状态码<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>具体的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<ul>
<li><p>1xx<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>指示信息–表示请求已接收<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>继续处理<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
</li>
<li><p>2xx<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>成功–表示请求正常处理完毕<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
</li>
<li><p>200 OK<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>客户端请求被正常处理<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
</li>
<li><p>206 Partial content<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>客户端进行了范围请求<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
</li>
<li><p>3xx<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>重定向–要完成请求必须进行更进一步的操作</p>
</li>
<li><p>301 Moved Permanently<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>永久重定向<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>该资源已被永久移动到新位置<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>将来任何对该资源的访问都要使用本响应返回的若干个URI之一<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
</li>
<li><p>302 Found<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>临时重定向<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>请求的资源现在临时从不同的URI中获得<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
</li>
<li><p>4xx<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>客户端错误–请求有语法错误<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>服务器无法处理请求<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
</li>
<li><p>400 Bad Request<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>请求报文存在语法错误<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
</li>
<li><p>403 Forbidden<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>请求被服务器拒绝<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
</li>
<li><p>404 Not Found<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>请求不存在<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>服务器上找不到请求的资源<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
</li>
<li><p>5xx<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>服务器端错误–服务器处理请求出错<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
</li>
<li><p>500 Internal Server Error<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>服务器在执行请求时出现错误<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
</li>
</ul>
<h3 id="HTTP请求解析"><a href="#HTTP请求解析" class="headerlink" title="HTTP请求解析"></a>HTTP请求解析</h3><p>有限状态机<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>是一种抽象的理论模型<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>它能够把有限个变量描述的状态变化过程<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>以可构造可验证的方式呈现出来<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>比如<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>封闭的有向图<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>有限状态机可以通过if-else,switch-case和函数指针来实现<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>从软件工程的角度看<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>主要是为了封装逻辑<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>首先对http报文处理的流程进行简要介绍<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>然后具体介绍http类的定义和服务器接收http请求的具体过程<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<ul>
<li><p>浏览器端发出http连接请求<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>主线程创建http对象接收请求并将所有数据读入对应buffer<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>将该对象插入任务队列<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>工作线程从任务队列中取出一个任务进行处理<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<ul>
<li><p>工作线程取出任务后<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>调用process_read函数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>通过主<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>从状态机对请求报文进行解析<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
</li>
<li><p>解析完之后<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>跳转do_request函数生成响应报文<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>通过process_write写入buffer<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>返回给浏览器端<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
</li>
</ul>
</li>
</ul>
<p>在HTTP报文中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>每一行的数据由\r\n作为结束字符<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>空行则是仅仅是字符\r\n<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>因此<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以通过查找\r\n将报文拆解成单独的行进行解析<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>项目中便是利用了这一点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>从状态机负责读取buffer中的数据<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>将每行数据末尾的\r\n置为\0\0<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并更新从状态机在buffer中读取的位置m_checked_idx<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>以此来驱动主状态机解析<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<ul>
<li><p>从状态机从m_read_buf中逐字节读取<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>判断当前字节是否为\r</p>
<ul>
<li><p>接下来的字符是\n<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>将\r\n修改成\0\0<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>将m_checked_idx指向下一行的开头<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则返回LINE_OK</p>
</li>
<li><p>接下来达到了buffer末尾<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>表示buffer还需要继续接收<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>返回LINE_OPEN</p>
</li>
<li><p>否则<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>表示语法错误<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>返回LINE_BAD</p>
</li>
</ul>
</li>
<li><p>当前字节不是\r<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>判断是否是\n<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span><strong>一般是上次读取到\r就到了buffer末尾<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>没有接收完整<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>再次接收时会出现这种情况</strong><span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span></p>
<ul>
<li>如果前一个字符是\r<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则将\r\n修改成\0\0<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>将m_checked_idx指向下一行的开头<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则返回LINE_OK</li>
</ul>
</li>
<li><p>当前字节既不是\r<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>也不是\n</p>
<ul>
<li>表示接收不完整<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>需要继续接收<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>返回LINE_OPEN</li>
</ul>
</li>
</ul>
<h4 id="主从状态机"><a href="#主从状态机" class="headerlink" title="主从状态机"></a>主从状态机</h4><p>流程图和代码分别对状态机和服务器解析请求报文进行详解<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><br><strong>流程图部分</strong><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>描述主<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>从状态机调用关系与状态转移过程<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><br><strong>代码部分</strong><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>结合代码对http请求报文的解析进行详解<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><img src="/img/loading.gif" data-original="images/Pasted%20image%2020230410205729.png"></p>
<ul>
<li><strong>主状态机</strong></li>
</ul>
<p>三种状态<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>标识解析位置<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<ul>
<li><p>CHECK_STATE_REQUESTLINE<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>解析请求行</p>
</li>
<li><p>CHECK_STATE_HEADER<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>解析请求头</p>
</li>
<li><p>CHECK_STATE_CONTENT<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>解析消息体<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>仅用于解析POST请求</p>
</li>
<li><p><strong>从状态机</strong></p>
</li>
</ul>
<p>三种状态<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>标识解析一行的读取状态<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<ul>
<li><p>LINE_OK<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>完整读取一行</p>
</li>
<li><p>LINE_BAD<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>报文语法有误</p>
</li>
<li><p>LINE_OPEN<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>读取的行不完整</p>
</li>
</ul>
<p>在http请求接收部分<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>会涉及到init和read_once函数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>但init仅仅是对私有成员变量进行初始化<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>不用过多讲解<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>这里<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>对read_once进行介绍<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>read_once读取浏览器端发送来的请求报文<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>直到无数据可读或对方关闭连接<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>读取到m_read_buffer中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并更新m_read_idx<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h4 id="HTTP-CODE含义"><a href="#HTTP-CODE含义" class="headerlink" title="HTTP_CODE含义"></a><strong>HTTP_CODE含义</strong></h4><p>表示HTTP请求的处理结果<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>在头文件中初始化了八种情形<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>在报文解析时只涉及到四种<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<ul>
<li><p>NO_REQUEST: 请求不完整<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>需要继续读取请求报文数据</p>
</li>
<li><p>GET_REQUEST: 获得了完整的HTTP请求</p>
</li>
<li><p>BAD_REQUEST: HTTP请求报文有语法错误</p>
</li>
<li><p>INTERNAL_ERROR: 服务器内部错误<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>该结果在主状态机逻辑switch的default下<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>一般不会触发</p>
</li>
</ul>
<h4 id="解析报文整体流程"><a href="#解析报文整体流程" class="headerlink" title="解析报文整体流程"></a><strong>解析报文整体流程</strong></h4><p>process_read通过while循环<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>将主从状态机进行封装<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>对报文的每一行进行循环处理<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h5 id="循环条件"><a href="#循环条件" class="headerlink" title="循环条件"></a>循环条件</h5><pre><code class="c++">while((m_check_state==CHECK_STATE_CONTENT &amp;&amp; line_status==LINE_OK)||((line_status=parse_line())==LINE_OK))
</code></pre>
<p>在GET请求报文中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>每一行都是\r\n作为结束<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以对报文进行拆解时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>仅用从状态机的状态line_status&#x3D;parse_line())&#x3D;&#x3D;LINE_OK语句即可<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>但<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>在POST请求报文中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>消息体的末尾没有任何字符<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以不能使用从状态机的状态<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这里转而使用主状态机的状态作为循环入口条件<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<ul>
<li><p>判断条件</p>
<ul>
<li><p>主状态机转移到CHECK_STATE_CONTENT<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>该条件涉及解析消息体</p>
</li>
<li><p>从状态机转移到LINE_OK<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>该条件涉及解析请求行和请求头部</p>
</li>
<li><p>两者为或关系<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>当条件为真则继续循环<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>否则退出</p>
</li>
</ul>
</li>
<li><p>循环体</p>
<ul>
<li><p>从状态机读取数据</p>
</li>
<li><p>调用get_line函数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>通过m_start_line将从状态机读取数据间接赋给text</p>
</li>
<li><p>主状态机解析text</p>
</li>
</ul>
</li>
</ul>
<p>解析完消息体后<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>报文的完整解析就完成了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>但此时主状态机的状态还是CHECK_STATE_CONTENT<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>也就是说<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>符合循环入口条件<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>还会再次进入循环<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这并不是我们所希望的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>为此<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>增加了该语句<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并在完成消息体解析后<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>将line_status变量更改为LINE_OPEN<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>此时可以跳出循环<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>完成报文解析任务<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h5 id="CHECK-STATE-REQUESTLINE"><a href="#CHECK-STATE-REQUESTLINE" class="headerlink" title="CHECK_STATE_REQUESTLINE"></a>CHECK_STATE_REQUESTLINE</h5><p>主状态机初始状态是CHECK_STATE_REQUESTLINE<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>通过调用从状态机来驱动主状态机<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>在主状态机进行解析前<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>从状态机已经将每一行的末尾\r\n符号改为\0\0<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>以便于主状态机直接取出对应字符串进行处理<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<ul>
<li><p>CHECK_STATE_REQUESTLINE</p>
<ul>
<li>主状态机的初始状态<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>调用parse_request_line函数解析请求行</li>
<li>解析函数从m_read_buf中解析HTTP请求行<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>获得请求方法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>目标URL及HTTP版本号</li>
<li>解析完成后主状态机的状态变为CHECK_STATE_HEADER</li>
</ul>
</li>
</ul>
<p>解析完请求行后<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>主状态机继续分析请求头<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>在报文中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>请求头和空行的处理使用的同一个函数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这里通过判断当前的text首位是不是\0字符<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>若是<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则表示当前处理的是空行<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>若不是<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则表示当前处理的是请求头<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h5 id="CHECK-STATE-HEADER"><a href="#CHECK-STATE-HEADER" class="headerlink" title="CHECK_STATE_HEADER"></a>CHECK_STATE_HEADER</h5><ul>
<li><p>CHECK_STATE_HEADER</p>
<ul>
<li><p>调用parse_headers函数解析请求头部信息</p>
</li>
<li><p>判断是空行还是请求头<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>若是空行<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>进而判断content-length是否为0<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果不是0<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>表明是POST请求<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则状态转移到CHECK_STATE_CONTENT<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>否则说明是GET请求<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则报文解析结束<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
</li>
<li><p>若解析的是请求头部字段<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则主要分析connection字段<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>content-length字段<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其他字段可以直接跳过<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>各位也可以根据需求继续分析<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
</li>
<li><p>若解析的是请求头部字段<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则主要分析connection字段<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>content-length字段<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其他字段可以直接跳过<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>各位也可以根据需求继续分析<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>  connection字段判断是keep-alive还是close<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>决定是长连接还是短连接</p>
</li>
<li><p>content-length字段<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这里用于读取post请求的消息体长度</p>
</li>
</ul>
</li>
</ul>
<p>如果仅仅是GET请求<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如项目中的欢迎界面<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么主状态机只设置之前的两个状态足矣<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>因为在上篇推文中我们曾说道<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>GET和POST请求报文的区别之一是有无消息体部分<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>GET请求没有消息体<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>当解析完空行之后<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>便完成了报文的解析<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>但后续的登录和注册功能<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>为了避免将用户名和密码直接暴露在URL中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们在项目中改用了POST请求<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>将用户名和密码添加在报文中作为消息体进行了封装<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>为此<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们需要在解析报文的部分添加解析消息体的模块<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h5 id="CHECK-STATE-CONTENT"><a href="#CHECK-STATE-CONTENT" class="headerlink" title="CHECK_STATE_CONTENT"></a>CHECK_STATE_CONTENT</h5><ul>
<li><p>仅用于解析POST请求<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>调用parse_content函数解析消息体</p>
</li>
<li><p>用于保存post请求消息体<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>为后面的登录和注册做准备</p>
</li>
</ul>
<h3 id="HTTP响应处理"><a href="#HTTP响应处理" class="headerlink" title="HTTP响应处理"></a>HTTP响应处理</h3><h4 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识:"></a>基础知识:</h4><p>介绍<code>stat</code><span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span><code>mmap</code><span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span><code>iovec</code><span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span><code>writev</code></p>
<h5 id="stat"><a href="#stat" class="headerlink" title="stat"></a><strong>stat</strong></h5><p>stat函数用于取得指定文件的文件属性<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并将文件属性存储在结构体stat里<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这里仅对其中用到的成员进行介绍<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<pre><code class="c++">#include &lt;sys/stat.h&gt;

//获取文件属性&lt;span class=&quot;bd-box&quot;&gt;&lt;h-char class=&quot;bd bd-beg&quot;&gt;&lt;h-inner&gt;，&lt;/h-inner&gt;&lt;/h-char&gt;&lt;/span&gt;存储在statbuf中
int stat(const char *pathname, struct stat *statbuf);

//完整定义很长, 仅介绍用到的
struct stat   
&#123;  
   mode_t    st_mode;        /* 文件类型和权限 */  
   off_t     st_size;        /* 文件大小&lt;span class=&quot;bd-box&quot;&gt;&lt;h-char class=&quot;bd bd-beg&quot;&gt;&lt;h-inner&gt;，&lt;/h-inner&gt;&lt;/h-char&gt;&lt;/span&gt;字节数*/  
&#125;;

stat(m_real_file, &amp;m_file_stat)&lt;0
</code></pre>
<h5 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a><strong>mmap</strong></h5><p>用于将一个文件或其他对象映射到内存<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>提高文件的访问速度<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<pre><code class="c++">void* mmap(void* start,size_t length,int prot,int flags,int fd,off_t offset);
int munmap(void* start,size_t length);
</code></pre>
<ul>
<li><p>start<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>映射区的开始地址<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>设置为0时表示由系统决定映射区的起始地址</p>
</li>
<li><p>length<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>映射区的长度</p>
</li>
<li><p>prot<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>期望的内存保护标志<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>不能与文件的打开模式冲突</p>
<ul>
<li>PROT_READ 表示页内容可以被读取</li>
</ul>
</li>
<li><p>flags<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>指定映射对象的类型<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>映射选项和映射页是否可以共享</p>
<ul>
<li>MAP_PRIVATE 建立一个写入时拷贝的私有映射<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>内存区域的写入不会影响到原文件</li>
</ul>
</li>
<li><p>fd<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>有效的文件描述符<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>一般是由open()函数返回</p>
</li>
<li><p>off_toffset<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>被映射对象内容的起点</p>
</li>
</ul>
<h5 id="iovec"><a href="#iovec" class="headerlink" title="iovec"></a><strong>iovec</strong></h5><p>定义了一个向量元素<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>通常<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这个结构用作一个多元素的数组<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<pre><code class="c++">struct iovec
&#123;
  void *iov_base;	/* Pointer to data.  */
  size_t iov_len;	/* Length of data.  */
&#125;;
</code></pre>
<ul>
<li>iov_base指向数据的地址</li>
<li>iov_len表示数据的长度</li>
</ul>
<h5 id="writenv"><a href="#writenv" class="headerlink" title="writenv"></a>writenv</h5><p>writev函数用于在一次函数调用中写多个非连续缓冲区<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>有时也将这该函数称为聚集写<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<pre><code class="c++">#include &lt;sys/uio.h&gt;
ssize_t writev(int filedes, const struct iovec *iov, int iovcnt);
</code></pre>
<ul>
<li><p>filedes表示文件描述符</p>
</li>
<li><p>iov为前述io向量机制结构体iovec</p>
</li>
<li><p>iovcnt为结构体的个数</p>
</li>
</ul>
<p>若成功则返回已写的字节数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>若出错则返回-1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><code>writev</code>以顺序<code>iov[0]</code><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><code>iov[1]</code>至<code>iov[iovcnt-1]</code>从缓冲区中聚集输出数据<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><code>writev</code>返回输出的字节总数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>通常<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>它应等于所有缓冲区长度之和<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><strong>特别注意<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></strong> 循环调用writev时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>需要重新处理iovec中的指针和长度<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>该函数不会对这两个成员做任何处理<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>writev的返回值为已写的字节数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>但这个返回值<span class="bd-box"><h-char class="bd bd-end"><h-inner>“</h-inner></h-char></span>实用性<span class="bd-box"><h-char class="bd bd-beg"><h-inner>”</h-inner></h-char></span>并不高<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因为参数传入的是iovec数组<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>计量单位是iovcnt<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而不是字节数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们仍然需要通过遍历iovec来计算新的基址<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>另外写入数据的<span class="bd-box"><h-char class="bd bd-end"><h-inner>“</h-inner></h-char></span>结束点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>”</h-inner></h-char></span>可能位于一个iovec的中间某个位置<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因此需要调整临界iovec的io_base和io_len<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h4 id="do-request"><a href="#do-request" class="headerlink" title="do_request()"></a><code>do_request()</code></h4><p>浏览器端发出HTTP请求报文<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>服务器端接收该报文并调用<code>process_read</code>对其进行解析<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>根据解析结果<code>HTTP_CODE</code><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>进入相应的逻辑和模块<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>其中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>服务器子线程完成报文的解析与响应<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>主线程监测读写事件<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>调用<code>read_once</code>和<code>http_conn::write</code>完成数据的读取与发送<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><img src="/img/loading.gif" data-original="images/Pasted%20image%2020230412172650.png"></p>
<p><code>process_read</code>函数的返回值是对请求的文件分析后的结果<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>一部分是语法错误导致的<code>BAD_REQUEST</code><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>一部分是<code>do_request</code>的返回结果.该函数将网站根目录和<code>url</code>文件拼接<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>然后通过stat判断该文件属性<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>另外<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>为了提高访问速度<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>通过mmap进行映射<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>将普通文件映射到内存逻辑地址<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>为了更好的理解请求资源的访问流程<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这里对各种各页面跳转机制进行简要介绍<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>其中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>浏览器网址栏中的字符<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>即<code>url</code><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以将其抽象成<code>ip:port/xxx</code><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><code>xxx</code>通过<code>html</code>文件的<code>action</code>属性进行设置<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>m_url为请求报文中解析出的请求资源<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>以&#x2F;开头<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>也就是<code>/xxx</code><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>项目中解析后的m_url有8种情况<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>m_url为请求报文中解析出的请求资源<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>以&#x2F;开头<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>也就是<code>/xxx</code><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>项目中解析后的m_url有8种情况<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<ul>
<li><p>&#x2F;</p>
</li>
<li><p>GET请求<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>跳转到judge.html<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>即欢迎访问页面</p>
</li>
<li><p>&#x2F;0</p>
</li>
<li><p>POST请求<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>跳转到register.html<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>即注册页面</p>
</li>
<li><p>&#x2F;1</p>
</li>
<li><p>POST请求<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>跳转到log.html<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>即登录页面</p>
</li>
<li><p>&#x2F;2CGISQL.cgi</p>
</li>
<li><p>POST请求<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>进行登录校验</p>
</li>
<li><p>验证成功跳转到welcome.html<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>即资源请求成功页面</p>
</li>
<li><p>验证失败跳转到logError.html<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>即登录失败页面</p>
</li>
<li><p>&#x2F;3CGISQL.cgi</p>
</li>
<li><p>POST请求<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>进行注册校验</p>
</li>
<li><p>注册成功跳转到log.html<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>即登录页面</p>
</li>
<li><p>注册失败跳转到registerError.html<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>即注册失败页面</p>
</li>
<li><p>&#x2F;5</p>
</li>
<li><p>POST请求<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>跳转到picture.html<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>即图片请求页面</p>
</li>
<li><p>&#x2F;6</p>
</li>
<li><p>POST请求<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>跳转到video.html<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>即视频请求页面</p>
</li>
<li><p>&#x2F;7</p>
</li>
<li><p>POST请求<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>跳转到fans.html<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>即关注页面</p>
</li>
</ul>
<h4 id="process-write"><a href="#process-write" class="headerlink" title="process_write()"></a><code>process_write()</code></h4><p>根据<code>do_request</code>的返回状态<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>服务器子线程调用<code>process_write</code>向<code>m_write_buf</code>中写入响应报文<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<ul>
<li><p>add_status_line函数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>添加状态行<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>http&#x2F;1.1 状态码 状态消息</p>
</li>
<li><p>add_headers函数添加消息报头<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>内部调用add_content_length和add_linger函数</p>
</li>
<li><p>content-length记录响应报文长度<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>用于浏览器端判断服务器是否发送完数据</p>
</li>
<li><p>connection记录连接状态<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>用于告诉浏览器端保持长连接</p>
</li>
<li><p>add_blank_line添加空行</p>
</li>
</ul>
<p>上述涉及的5个函数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>均是内部调用<code>add_response</code>函数更新<code>m_write_idx</code>指针和缓冲区<code>m_write_buf</code>中的内容<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>响应报文分为两种<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>一种是请求文件的存在<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>通过<code>io</code>向量机制<code>iovec</code><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>声明两个<code>iovec</code><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>第一个指向<code>m_write_buf</code><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>第二个指向<code>mmap</code>的地址<code>m_file_address</code><span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>一种是请求出错<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这时候只申请一个<code>iovec</code><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>指向<code>m_write_buf</code><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<ul>
<li><p>iovec是一个结构体<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>里面有两个元素<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>指针成员iov_base指向一个缓冲区<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这个缓冲区是存放的是writev将要发送的数据<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
</li>
<li><p>成员iov_len表示实际写入的长度</p>
</li>
</ul>
<h4 id="http-conn-write"><a href="#http-conn-write" class="headerlink" title="http_conn::write()"></a><code>http_conn::write()</code></h4><p>服务器子线程调用<code>process_write</code>完成响应报文<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>随后注册<code>epollout</code>事件<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>服务器主线程检测写事件<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并调用<code>http_conn::write</code>函数将响应报文发送给浏览器端<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>该函数具体逻辑如下<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<p>在生成响应报文时初始化byte_to_send<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>包括头部信息和文件数据大小<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>通过writev函数循环发送响应报文数据<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>根据返回值更新byte_have_send和iovec结构体的指针和长度<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并判断响应报文整体是否发送成功<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<ul>
<li><p>若writev单次发送成功<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>更新byte_to_send和byte_have_send的大小<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>若响应报文整体发送成功,则取消mmap映射,并判断是否是长连接.</p>
<ul>
<li><p>长连接重置http类实例<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>注册读事件<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>不关闭连接<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span></p>
</li>
<li><p>短连接直接关闭连接</p>
</li>
</ul>
</li>
<li><p>若writev单次发送不成功<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>判断是否是写缓冲区满了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<ul>
<li><p>若不是因为缓冲区满了而失败<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>取消mmap映射<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>关闭连接</p>
</li>
<li><p>若eagain则满了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>更新iovec结构体的指针和长度<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并注册写事件<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>等待下一次写事件触发<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>当写缓冲区从不可写变为可写<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>触发epollout<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因此在此期间无法立即接收到同一用户的下一请求<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>但可以保证连接的完整性<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
</li>
</ul>
</li>
</ul>
<h2 id="05定时器处理非活动连接"><a href="#05定时器处理非活动连接" class="headerlink" title="05定时器处理非活动连接"></a>05定时器处理非活动连接</h2><p>由于非活跃连接占用了连接资源<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>严重影响服务器的性能<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>通过实现一个服务器定时器<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>处理这种非活跃连接<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>释放连接资源<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>利用alarm函数周期性地触发SIGALRM信号,该信号的信号处理函数利用管道通知主循环执行定时器链表上的定时任务.</p>
<ul>
<li>统一事件源 </li>
<li>基于升序链表的定时器</li>
<li>处理非活动连接</li>
</ul>
<p><code>非活跃</code><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>是指客户端<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>这里是浏览器<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>与服务器端建立连接后<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>长时间不交换数据<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>一直占用服务器端的文件描述符<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>导致连接资源的浪费<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><code>定时事件</code><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>是指固定一段时间之后触发某段代码<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>由该段代码处理一个事件<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如从内核事件表删除事件<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并关闭文件描述符<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>释放连接资源<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><code>定时器</code><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>是指利用结构体或其他形式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>将多种定时事件进行封装起来<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>具体的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这里只涉及一种定时事件<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>即定期检测非活跃连接<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这里将该定时事件与连接资源封装为一个结构体定时器<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><code>定时器容器</code><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>是指使用某种容器类数据结构<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>将上述多个定时器组合起来<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>便于对定时事件统一管理<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>具体的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>项目中使用升序链表将所有定时器串联组织起来<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>本项目中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>服务器主循环为每一个连接创建一个定时器<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并对每个连接进行定时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>另外<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>利用升序时间链表容器将所有定时器串联起来<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>若主循环接收到定时通知<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则在链表中依次执行定时任务<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><code>Linux</code>下提供了三种定时的方法:</p>
<ul>
<li><p>socket选项SO_RECVTIMEO和SO_SNDTIMEO</p>
</li>
<li><p>SIGALRM信号</p>
</li>
<li><p>I&#x2F;O复用系统调用的超时参数</p>
</li>
</ul>
<p>三种方法没有一劳永逸的应用场景<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>也没有绝对的优劣<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>由于项目中使用的是<code>SIGALRM</code>信号<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这里仅对其进行介绍<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>另外两种方法可以查阅游双的<code>Linux高性能服务器编程 第11章 定时器</code><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>具体的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>利用<code>alarm</code>函数周期性地触发<code>SIGALRM</code>信号<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>信号处理函数利用管道通知主循环<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>主循环接收到该信号后对升序链表上所有定时器进行处理<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>若该段时间内没有交换数据<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则将该连接关闭<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>释放所占用的资源<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>从上面的简要描述中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以看出定时器处理非活动连接模块<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>主要分为两部分<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其一为定时方法与信号通知流程<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其二为定时器及其容器设计与定时任务的处理<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><strong>基础API</strong><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>描述<code>sigaction</code>结构体<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span><code>sigaction</code>函数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span><code>sigfillset</code>函数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span><code>SIGALRM</code>信号<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span><code>SIGTERM</code>信号<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span><code>alarm</code>函数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span><code>socketpair</code>函数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span><code>send</code>函数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><strong>信号通知流程</strong><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>介绍统一事件源和信号处理机制<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><strong>代码实现</strong><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>结合代码对信号处理函数的设计与使用进行详解<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h3 id="信号通知流程"><a href="#信号通知流程" class="headerlink" title="信号通知流程"></a>信号通知流程</h3><p>Linux下的信号采用的异步处理机制<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>信号处理函数和当前进程是两条不同的执行路线<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>具体的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>当进程收到信号时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>操作系统会中断进程当前的正常流程<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>转而进入信号处理函数执行操作<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>完成后再返回中断的地方继续执行<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>为避免信号竞态现象发生<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>信号处理期间系统不会再次触发它<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>所以<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>为确保该信号不被屏蔽太久<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>信号处理函数需要尽可能快地执行完毕<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>一般的信号处理函数需要处理该信号对应的逻辑<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>当该逻辑比较复杂时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>信号处理函数执行时间过长<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>会导致信号屏蔽太久<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>这里的解决方案是<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>信号处理函数仅仅发送信号通知程序主循环<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>将信号对应的处理逻辑放在程序主循环中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>由主循环执行信号对应的逻辑代码<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h4 id="统一事件源"><a href="#统一事件源" class="headerlink" title="统一事件源"></a><strong>统一事件源</strong></h4><p>统一事件源<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>是指将信号事件与其他事件一样被处理<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>具体的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>信号处理函数使用管道将信号传递给主循环<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>信号处理函数往管道的写端写入信号值<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>主循环则从管道的读端读出信号值<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>使用I&#x2F;O复用系统调用来监听管道读端的可读事件<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这样信号事件与其他文件描述符都可以通过epoll来监测<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>从而实现统一处理<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h4 id="信号处理机制"><a href="#信号处理机制" class="headerlink" title="信号处理机制"></a><strong>信号处理机制</strong></h4><p>每个进程之中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>都有存着一个表<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>里面存着每种信号所代表的含义<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>内核通过设置表项中每一个位来标识对应的信号类型<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><img src="/img/loading.gif" data-original="images/Pasted%20image%2020230505155709.png"></p>
<ul>
<li><p>信号的接收</p>
</li>
<li><p>接收信号的任务是由内核代理的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>当内核接收到信号后<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>会将其放到对应进程的信号队列中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>同时向进程发送一个中断<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>使其陷入内核态<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>注意<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>此时信号还只是在队列中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>对进程来说暂时是不知道有信号到来的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
</li>
<li><p>信号的检测</p>
</li>
<li><p>进程从内核态返回到用户态前进行信号检测</p>
</li>
<li><p>进程在内核态中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>从睡眠状态被唤醒的时候进行信号检测</p>
</li>
<li><p>进程陷入内核态后<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>有两种场景会对信号进行检测<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
</li>
<li><p>当发现有新信号时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>便会进入下一步<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>信号的处理<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
</li>
<li><p>信号的处理</p>
</li>
<li><p>( <strong>内核</strong> )信号处理函数是运行在用户态的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>调用处理函数前<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>内核会将当前内核栈的内容备份拷贝到用户栈上<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并且修改指令寄存器<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>eip<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>将其指向信号处理函数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
</li>
<li><p>( <strong>用户</strong> )接下来进程返回到用户态中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>执行相应的信号处理函数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
</li>
<li><p>( <strong>内核</strong> )信号处理函数执行完成后<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>还需要返回内核态<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>检查是否还有其它信号未处理<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
</li>
<li><p>( <strong>用户</strong> )如果所有信号都处理完成<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>就会将内核栈恢复<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>从用户栈的备份拷贝回来<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>同时恢复指令寄存器<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>eip<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>将其指向中断前的运行位置<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>最后回到用户态继续执行进程<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
</li>
</ul>
<p>至此<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>一个完整的信号处理流程便结束了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果同时有多个信号到达<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>上面的处理流程会在第2步和第3步骤间重复进行<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h3 id="定时器容器"><a href="#定时器容器" class="headerlink" title="定时器容器"></a>定时器容器</h3><p>项目中的定时器容器为带头尾结点的升序双向链表<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>具体的为每个连接创建一个定时器<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>将其添加到链表中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并按照超时时间升序排列<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>执行定时任务时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>将到期的定时器从链表中删除<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>从实现上看<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>主要涉及双向链表的插入<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>删除操作<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其中添加定时器的事件复杂度是O(n),删除定时器的事件复杂度是O(1)<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>升序双向链表主要逻辑如下<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>具体的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span></p>
<ul>
<li><p>创建头尾节点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其中头尾节点没有意义<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>仅仅统一方便调整</p>
</li>
<li><p>add_timer函数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>将目标定时器添加到链表中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>添加时按照升序添加</p>
</li>
<li><p>若当前链表中只有头尾节点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>直接插入</p>
</li>
<li><p>否则<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>将定时器按升序插入</p>
</li>
<li><p>adjust_timer函数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>当定时任务发生变化,调整对应定时器在链表中的位置</p>
</li>
<li><p>客户端在设定时间内有数据收发,则当前时刻对该定时器重新设定时间<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这里只是往后延长超时时间</p>
</li>
<li><p>被调整的目标定时器在尾部<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>或定时器新的超时值仍然小于下一个定时器的超时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>不用调整</p>
</li>
<li><p>否则先将定时器从链表取出<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>重新插入链表</p>
</li>
<li><p>del_timer函数将超时的定时器从链表中删除</p>
</li>
<li><p>常规双向链表删除结点</p>
</li>
</ul>
<h2 id="06日志系统"><a href="#06日志系统" class="headerlink" title="06日志系统"></a>06日志系统</h2><p>同步&#x2F;异步日志系统主要涉及了两个模块<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>一个是日志模块<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>一个是阻塞队列模块,其中加入阻塞队列模块主要是解决异步写入日志做准备.</p>
<blockquote>
<ul>
<li>自定义阻塞队列</li>
<li>单例模式创建日志</li>
<li>同步日志</li>
<li>异步日志</li>
<li>实现按天<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>超行分类</li>
</ul>
</blockquote>
<p><img src="/img/loading.gif" data-original="images/Pasted%20image%2020230518154153.png"></p>
<p><strong><code>日志</code></strong><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>由服务器自动创建<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并记录运行状态<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>错误信息<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>访问数据的文件<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><strong><code>同步日志</code></strong><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>日志写入函数与工作线程串行执行<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>由于涉及到I&#x2F;O操作<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>当单条日志比较大的时候<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>同步模式会阻塞整个处理流程<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>服务器所能处理的并发能力将有所下降<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>尤其是在峰值的时候<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>写日志可能成为系统的瓶颈<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><strong><code>生产者-消费者模型</code></strong><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并发编程中的经典模型<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>以多线程为例<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>为了实现线程间数据同步<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>生产者线程与消费者线程共享一个缓冲区<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其中生产者线程往缓冲区中push消息<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>消费者线程从缓冲区中pop消息<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><strong><code>阻塞队列</code></strong><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>将生产者-消费者模型进行封装<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>使用循环数组实现队列<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>作为两者共享的缓冲区<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><strong><code>异步日志</code></strong><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>将所写的日志内容先存入阻塞队列<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>写线程从阻塞队列中取出内容<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>写入日志<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><strong><code>单例模式</code></strong><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>最简单也是被问到最多的设计模式之一<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>保证一个类只创建一个实例<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>同时提供全局访问的方法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>本项目中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>使用单例模式创建日志系统<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>对服务器运行状态<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>错误信息和访问数据进行记录<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>该系统可以实现按天分类<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>超行分类功能<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以根据实际情况分别使用同步和异步写入两种方式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>其中异步写入方式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>将生产者-消费者模型封装为阻塞队列<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>创建一个写线程<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>工作线程将要写的内容push进队列<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>写线程从队列中取出内容<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>写入日志文件<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>日志系统大致可以分成两部分<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其一是单例模式与阻塞队列的定义<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其二是日志类的定义与使用<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<blockquote>
<p><strong>单例模式</strong><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>描述懒汉与饿汉两种单例模式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并结合线程安全进行讨论<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><strong>生产者-消费者模型</strong><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>描述条件变量<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>基于该同步机制实现简单的生产者-消费者模型<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><strong>代码实现</strong><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>结合代码对阻塞队列的设计进行详解<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
</blockquote>
<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>单例模式作为最常用的设计模式之一<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>保证一个类仅有一个实例<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并提供一个访问它的全局访问点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>该实例被所有程序模块共享<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>实现思路<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>私有化它的构造函数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>以防止外界创建单例类的对象<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>使用类的私有静态指针变量指向类的唯一实例<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并用一个公有的静态方法获取该实例<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>单例模式有两种实现方法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>分别是懒汉和饿汉模式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>顾名思义<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>懒汉模式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>即非常懒<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>不用的时候不去初始化<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以在第一次被使用时才进行初始化<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>饿汉模式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>即迫不及待<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>在程序运行时立即初始化<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h3 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h3><p>阻塞队列是一种特殊的队列数据结构<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>它具有阻塞功能<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>当队列为空时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>从队列中取元素的操作会被阻塞<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>直到队列中有新的元素被加入<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>同样地<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>当队列已满时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>向队列中添加元素的操作也会被阻塞<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>直到队列中有空闲位置<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>通过阻塞队列<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们可以很方便地实现线程间的协作和同步<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>比如<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>一个线程可以往阻塞队列中添加任务<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>另一个线程可以从队列中取出任务并执行<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>如果队列为空<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>取任务的线程就会被阻塞<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>直到有新的任务被添加到队列中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>如果队列已满<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>添加任务的线程就会被阻塞<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>直到队列中有空闲位置<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h2 id="07WebServer"><a href="#07WebServer" class="headerlink" title="07WebServer"></a>07WebServer</h2><h3 id="总流程"><a href="#总流程" class="headerlink" title="总流程"></a>总流程</h3><p><img src="/img/loading.gif" data-original="images/Pasted%20image%2020230518160318.png"></p>
<p><strong>流程图</strong><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>描述服务器从报文中提取出用户名密码<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并完成注册和登录校验后<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>实现页面跳转的逻辑<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><strong>载入数据库表</strong><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>结合代码将数据库中的数据载入到服务器中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><strong>提取用户名和密码</strong><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>结合代码对报文进行解析<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>提取用户名和密码<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><strong>注册登录流程</strong><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>结合代码对描述服务器进行注册和登录校验的流程<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><strong>页面跳转</strong><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>结合代码对页面跳转机制进行详解<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>

      
    </div>
    <footer class="article-footer">
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="../../way2/archives/" rel="tag">archives</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="../../way2/project/" rel="tag">project</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="../10/">&laquo; 上一页</a><a class="page-number" href="../../">1</a><span class="space">&hellip;</span><a class="page-number" href="../9/">9</a><a class="page-number" href="../10/">10</a><span class="page-number current">11</span><a class="page-number" href="../12/">12</a><a class="page-number" href="../13/">13</a><span class="space">&hellip;</span><a class="page-number" href="../18/">18</a><a class="extend next" rel="next" href="../12/">下一页 &raquo;</a>
  </nav>

</section>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
        <div id="footer-info" class="inner"> © 2023 <a href="https://github.com/kpkpy" target="_blank">kpkpy</a><br>Powered by <a href="https://hexo.io/" target="_blank">Hexo</a><br></div>
      
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="../../index.html" class="mobile-nav-link">Home</a>
  
    <a href="../../way2/archives" class="mobile-nav-link">Archives</a>
  
    <a href="../../about" class="mobile-nav-link">About</a>
  
</nav>
    

<script src="../../js/clipboard.min.js"></script>
<script src="../../js/jquery-1.4.3.min.js"></script>

<script src="../../fancybox/jquery.fancybox-1.3.4.pack.js"></script>


<script src="../../js/script.js"></script>






<script>
  MathJax = {
    options: {
      enableMenu: false
    },
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      displayMath: [['$$', '$$'], ['\\[', '\\]']],
    }
  };
</script>
<!-- <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]},
    CommonHTML: {
      linebreaks: false
    }
  });
  </script> -->
<script type="text/javascript" id="MathJax-script" async
  src="../../mathjax/tex-chtml.js">
</script>
<!-- <script type="text/javascript"
   src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-AMS_CHTML">
</script> -->



  </div>

        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>!function(r){r.imageLazyLoadSetting.processImages=t;var e=r.imageLazyLoadSetting.isSPA,n=r.imageLazyLoadSetting.preloadRatio||1,c=a();function a(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(){e&&(c=a());for(var t,o=0;o<c.length;o++)0<=(t=(t=c[o]).getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(r.innerHeight*n||document.documentElement.clientHeight*n)&&function(){var t,e,n,a,i=c[o];e=function(){c=c.filter(function(t){return i!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(i)},(t=i).hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(n=new Image,a=t.getAttribute("data-original"),n.onload=function(){t.src=a,t.removeAttribute("data-original"),e&&e()},t.src!==a&&(n.src=a))}()}function i(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",i),r.addEventListener("resize",i),r.addEventListener("orientationchange",i)}(this);</script></body>
</html>